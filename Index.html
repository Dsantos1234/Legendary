<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ZOOTOKEN - Web3 DeFi</title>
    <!-- Add ethers.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/6.8.1/ethers.umd.min.js"></script>
    <!-- Previous CSS styles remain the same -->
</head>
<body>
    <!-- Previous HTML structure remains the same -->

    <script>
        // Web3 Configuration
        const CONFIG = {
            contractAddress: '0x123...', // Your contract address
            chainId: '0x1', // Ethereum Mainnet
            supportedChains: {
                '0x1': 'Ethereum Mainnet',
                '0x89': 'Polygon Mainnet',
                '0xa86a': 'Avalanche'
            },
            // ABI for your smart contract
            contractABI: [
                "function stake(uint256 amount) external",
                "function withdraw(uint256 amount) external",
                "function getRewards() external view returns (uint256)",
                "function balanceOf(address account) external view returns (uint256)"
            ]
        };

        // State management
        let provider = null;
        let signer = null;
        let contract = null;
        let userAddress = null;

        // Initialize Web3
        async function initializeWeb3() {
            try {
                // Check if MetaMask is installed
                if (typeof window.ethereum !== 'undefined') {
                    // Create Web3 provider
                    provider = new ethers.BrowserProvider(window.ethereum);
                    
                    // Listen for account changes
                    window.ethereum.on('accountsChanged', handleAccountChange);
                    // Listen for chain changes
                    window.ethereum.on('chainChanged', handleChainChange);

                    // Update UI
                    updateConnectionButton();
                } else {
                    showToast('Please install MetaMask!', 'error');
                }
            } catch (error) {
                console.error('Error initializing Web3:', error);
                showToast('Failed to initialize Web3', 'error');
            }
        }

        // Connect Wallet
        async function connectWallet() {
            try {
                if (!provider) {
                    await initializeWeb3();
                }

                // Request account access
                const accounts = await window.ethereum.request({ 
                    method: 'eth_requestAccounts' 
                });
                
                userAddress = accounts[0];
                signer = await provider.getSigner();
                
                // Initialize contract
                contract = new ethers.Contract(
                    CONFIG.contractAddress,
                    CONFIG.contractABI,
                    signer
                );

                // Check network
                const network = await provider.getNetwork();
                if (!CONFIG.supportedChains[network.chainId]) {
                    await switchNetwork();
                }

                // Update UI
                updateUI();
                showToast('Wallet connected successfully!', 'success');
            } catch (error) {
                console.error('Error connecting wallet:', error);
                showToast('Failed to connect wallet', 'error');
            }
        }

        // Switch Network
        async function switchNetwork() {
            try {
                await window.ethereum.request({
                    method: 'wallet_switchEthereumChain',
                    params: [{ chainId: CONFIG.chainId }],
                });
            } catch (error) {
                if (error.code === 4902) {
                    showToast('Please add this network to your wallet', 'warning');
                }
            }
        }

        // Handle Account Change
        async function handleAccountChange(accounts) {
            if (accounts.length === 0) {
                // User disconnected wallet
                userAddress = null;
                signer = null;
                contract = null;
                updateUI();
                showToast('Wallet disconnected', 'warning');
            } else {
                userAddress = accounts[0];
                signer = await provider.getSigner();
                updateUI();
                showToast('Account changed', 'info');
            }
        }

        // Handle Chain Change
        function handleChainChange() {
            // Reload the page
            window.location.reload();
        }

        // Staking Function
        async function stake(poolId) {
            try {
                if (!contract) {
                    throw new Error('Please connect your wallet first');
                }

                const input = document.querySelector(`#stake-amount-${poolId}`);
                const amount = ethers.parseEther(input.value);

                // Show pending transaction
                showToast('Transaction pending...', 'info');

                // Send transaction
                const tx = await contract.stake(amount);
                
                // Wait for confirmation
                await tx.wait();

                // Update UI
                updateUI();
                showToast('Staking successful!', 'success');
            } catch (error) {
                console.error('Staking error:', error);
                showToast(error.message, 'error');
            }
        }

        // Withdraw Function
        async function withdraw(poolId) {
            try {
                if (!contract) {
                    throw new Error('Please connect your wallet first');
                }

                const input = document.querySelector(`#withdraw-amount-${poolId}`);
                const amount = ethers.parseEther(input.value);

                const tx = await contract.withdraw(amount);
                await tx.wait();

                updateUI();
                showToast('Withdrawal successful!', 'success');
            } catch (error) {
                console.error('Withdrawal error:', error);
                showToast(error.message, 'error');
            }
        }

        // Get User Balance
        async function getUserBalance() {
            try {
                if (!contract || !userAddress) return '0';
                
                const balance = await contract.balanceOf(userAddress);
                return ethers.formatEther(balance);
            } catch (error) {
                console.error('Error getting balance:', error);
                return '0';
            }
        }

        // Get User Rewards
        async function getUserRewards() {
            try {
                if (!contract || !userAddress) return '0';
                
                const rewards = await contract.getRewards();
                return ethers.formatEther(rewards);
            } catch (error) {
                console.error('Error getting rewards:', error);
                return '0';
            }
        }

        // Update UI
        async function updateUI() {
            const walletButton = document.getElementById('wallet-button');
            
            if (userAddress) {
                const shortAddress = `${userAddress.slice(0,6)}...${userAddress.slice(-4)}`;
                walletButton.textContent = shortAddress;
                
                // Update balances
                const balance = await getUserBalance();
                const rewards = await getUserRewards();
                
                // Update UI elements
                document.querySelectorAll('.user-balance').forEach(el => {
                    el.textContent = `${balance} ZOO`;
                });
                document.querySelectorAll('.user-rewards').forEach(el => {
                    el.textContent = `${rewards} ZOO`;
                });
            } else {
                walletButton.textContent = 'Connect Wallet';
            }
        }

        // Toast Notifications
        function showToast(message, type = 'info') {
            const toast = document.createElement('div');
            toast.className = `toast toast-${type} animate__animated animate__fadeIn`;
            toast.textContent = message;
            
            const container = document.querySelector('.toast-container');
            container.appendChild(toast);
            
            setTimeout(() => {
                toast.classList.replace('animate__fadeIn', 'animate__fadeOut');
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }

        // Initialize on load
        window.addEventListener('load', initializeWeb3);
    </script>
</body>
</html>
