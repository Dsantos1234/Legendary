// package.json
{
    "name": "solana-token-launcher",
    "version": "1.0.0",
    "description": "Token launcher for Solana blockchain",
    "main": "dist/index.js",
    "types": "dist/index.d.ts",
    "scripts": {
        "build": "tsc",
        "start": "node dist/index.js"
    },
    "dependencies": {
        "@solana/web3.js": "^1.87.6",
        "@solana/spl-token": "^0.3.8"
    },
    "devDependencies": {
        "typescript": "^5.0.0",
        "@types/node": "^18.0.0"
    }
}

// tsconfig.json
{
    "compilerOptions": {
        "target": "es2020",
        "module": "commonjs",
        "declaration": true,
        "outDir": "./dist",
        "strict": true,
        "esModuleInterop": true
    },
    "include": ["src"],
    "exclude": ["node_modules"]
}

// src/index.ts
import {
    Connection,
    Keypair,
    PublicKey,
    Transaction,
    sendAndConfirmTransaction,
} from '@solana/web3.js';
import {
    Token,
    TOKEN_PROGRAM_ID,
    ASSOCIATED_TOKEN_PROGRAM_ID,
    MintLayout,
} from '@solana/spl-token';

export class TokenLauncher {
    connection: Connection;
    payer: Keypair;

    constructor(connection: Connection, payer: Keypair) {
        this.connection = connection;
        this.payer = payer;
    }

    async createToken(
        name: string,
        symbol: string,
        decimals: number,
        initialSupply: number
    ): Promise<{ token: Token; mintAddress: PublicKey }> {
        try {
            const mintKeypair = Keypair.generate();
            const mintRent = await this.connection.getMinimumBalanceForRentExemption(
                MintLayout.span
            );

            const token = await Token.createMint(
                this.connection,
                this.payer,
                this.payer.publicKey,
                this.payer.publicKey,
                decimals,
                TOKEN_PROGRAM_ID
            );

            const tokenAccount = await token.getOrCreateAssociatedAccountInfo(
                this.payer.publicKey
            );

            await token.mintTo(
                tokenAccount.address,
                this.payer.publicKey,
                [],
                initialSupply * (10 ** decimals)
            );

            console.log('Token created successfully!');
            console.log('Mint address:', token.publicKey.toString());
            console.log('Token Account:', tokenAccount.address.toString());

            return {
                token,
                mintAddress: token.publicKey
            };
        } catch (error) {
            console.error('Error creating token:', error);
            throw error;
        }
    }

    async getTokenBalance(tokenAddress: PublicKey, ownerAddress: PublicKey): Promise<number> {
        try {
            const tokenAccount = await Token.getAssociatedTokenAddress(
                ASSOCIATED_TOKEN_PROGRAM_ID,
                TOKEN_PROGRAM_ID,
                tokenAddress,
                ownerAddress
            );

            const balance = await this.connection.getTokenAccountBalance(tokenAccount);
            return balance.value.uiAmount || 0;
        } catch (error) {
            console.error('Error getting token balance:', error);
            throw error;
        }
    }

    async transferTokens(
        token: Token,
        fromAddress: PublicKey,
        toAddress: PublicKey,
        amount: number
    ): Promise<string> {
        try {
            const fromTokenAccount = await token.getOrCreateAssociatedAccountInfo(
                fromAddress
            );
            const toTokenAccount = await token.getOrCreateAssociatedAccountInfo(
                toAddress
            );

            const transaction = new Transaction().add(
                Token.createTransferInstruction(
                    TOKEN_PROGRAM_ID,
                    fromTokenAccount.address,
                    toTokenAccount.address,
                    fromAddress,
                    [],
                    amount
                )
            );

            const signature = await sendAndConfirmTransaction(
                this.connection,
                transaction,
                [this.payer]
            );

            return signature;
        } catch (error) {
            console.error('Error transferring tokens:', error);
            throw error;
        }
    }
}

// Example usage
export const createExampleToken = async () => {
    const connection = new Connection('https://api.devnet.solana.com');
    const payer = Keypair.generate();
    const launcher = new TokenLauncher(connection, payer);

    const { token, mintAddress } = await launcher.createToken(
        "MyToken",
        "MTK",
        9,
        1000000
    );

    return { token, mintAddress };
};
      // src/utils/constants.ts
export const NETWORKS = {
    MAINNET: 'https://api.mainnet-beta.solana.com',
    DEVNET: 'https://api.devnet.solana.com',
    TESTNET: 'https://api.testnet.solana.com'
};

export const DEFAULT_DECIMALS = 9;

// src/utils/validation.ts
export const validateTokenParams = (
    name: string,
    symbol: string,
    decimals: number,
    initialSupply: number
): void => {
    if (!name || name.length < 2) throw new Error('Invalid token name');
    if (!symbol || symbol.length < 2) throw new Error('Invalid token symbol');
    if (decimals < 0 || decimals > 9) throw new Error('Decimals must be between 0 and 9');
    if (initialSupply <= 0) throw new Error('Initial supply must be greater than 0');
};

// src/types/index.ts
import { PublicKey } from '@solana/web3.js';
import { Token } from '@solana/spl-token';

export interface TokenInfo {
    token: Token;
    mintAddress: PublicKey;
}

export interface TokenMetadata {
    name: string;
    symbol: string;
    decimals: number;
    initialSupply: number;
}

// src/errors/index.ts
export class TokenLauncherError extends Error {
    constructor(message: string, public code: string) {
        super(message);
        this.name = 'TokenLauncherError';
    }
}

// src/index.ts (updated with error handling and validation)
import { Connection, Keypair, PublicKey, Transaction, sendAndConfirmTransaction } from '@solana/web3.js';
import { Token, TOKEN_PROGRAM_ID, ASSOCIATED_TOKEN_PROGRAM_ID, MintLayout } from '@solana/spl-token';
import { validateTokenParams } from './utils/validation';
import { TokenInfo, TokenMetadata } from './types';
import { TokenLauncherError } from './errors';
import { NETWORKS, DEFAULT_DECIMALS } from './utils/constants';

export class TokenLauncher {
    private connection: Connection;
    private payer: Keypair;

    constructor(connection: Connection, payer: Keypair) {
        this.connection = connection;
        this.payer = payer;
    }

    async createToken(metadata: TokenMetadata): Promise<TokenInfo> {
        try {
            validateTokenParams(
                metadata.name,
                metadata.symbol,
                metadata.decimals,
                metadata.initialSupply
            );

            const mintKeypair = Keypair.generate();
            await this.ensureMinimumBalance();

            const token = await this.createMintAndInitialize(metadata.decimals);
            await this.mintInitialSupply(token, metadata.initialSupply, metadata.decimals);

            return {
                token,
                mintAddress: token.publicKey
            };
        } catch (error) {
            throw new TokenLauncherError(
                `Failed to create token: ${error.message}`,
                'CREATE_TOKEN_ERROR'
            );
        }
    }

    private async ensureMinimumBalance(): Promise<void> {
        const balance = await this.connection.getBalance(this.payer.publicKey);
        const minimumBalance = await this.connection.getMinimumBalanceForRentExemption(
            MintLayout.span
        );

        if (balance < minimumBalance) {
            throw new TokenLauncherError(
                'Insufficient balance for token creation',
                'INSUFFICIENT_BALANCE'
            );
        }
    }

    private async createMintAndInitialize(decimals: number): Promise<Token> {
        return await Token.createMint(
            this.connection,
            this.payer,
            this.payer.publicKey,
            this.payer.publicKey,
            decimals,
            TOKEN_PROGRAM_ID
        );
    }

    private async mintInitialSupply(
        token: Token,
        initialSupply: number,
        decimals: number
    ): Promise<void> {
        const tokenAccount = await token.getOrCreateAssociatedAccountInfo(
            this.payer.publicKey
        );

        await token.mintTo(
            tokenAccount.address,
            this.payer.publicKey,
            [],
            initialSupply * (10 ** decimals)
        );
    }

    // Utility methods for token operations
    async getTokenBalance(tokenAddress: PublicKey, ownerAddress: PublicKey): Promise<number> {
        try {
            const tokenAccount = await Token.getAssociatedTokenAddress(
                ASSOCIATED_TOKEN_PROGRAM_ID,
                TOKEN_PROGRAM_ID,
                tokenAddress,
                ownerAddress
            );

            const balance = await this.connection.getTokenAccountBalance(tokenAccount);
            return balance.value.uiAmount || 0;
        } catch (error) {
            throw new TokenLauncherError(
                `Failed to get token balance: ${error.message}`,
                'GET_BALANCE_ERROR'
            );
        }
    }

    async transferTokens(
        token: Token,
        fromAddress: PublicKey,
        toAddress: PublicKey,
        amount: number
    ): Promise<string> {
        try {
            if (amount <= 0) {
                throw new Error('Transfer amount must be greater than 0');
            }

            const fromTokenAccount = await token.getOrCreateAssociatedAccountInfo(
                fromAddress
            );
            const toTokenAccount = await token.getOrCreateAssociatedAccountInfo(
                toAddress
            );

            const transaction = new Transaction().add(
                Token.createTransferInstruction(
                    TOKEN_PROGRAM_ID,
                    fromTokenAccount.address,
                    toTokenAccount.address,
                    fromAddress,
                    [],
                    amount
                )
            );

            return await sendAndConfirmTransaction(
                this.connection,
                transaction,
                [this.payer]
            );
        } catch (error) {
            throw new TokenLauncherError(
                `Failed to transfer tokens: ${error.message}`,
                'TRANSFER_ERROR'
            );
        }
    }
}

// Export utility functions and types
export { NETWORKS, DEFAULT_DECIMALS } from './utils/constants';
export { validateTokenParams } from './utils/validation';
export { TokenInfo, TokenMetadata } from './types';
export { TokenLauncherError } from './errors';

// Example usage
export const createExampleToken = async () => {
    const connection = new Connection(NETWORKS.DEVNET);
    const payer = Keypair.generate();
    const launcher = new TokenLauncher(connection, payer);

    const tokenMetadata: TokenMetadata = {
        name: "MyToken",
        symbol: "MTK",
        decimals: DEFAULT_DECIMALS,
        initialSupply: 1000000
    };

    return await launcher.createToken(tokenMetadata);
};
